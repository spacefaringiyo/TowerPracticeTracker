// PART 1 //

PROJECT STRUCTURE:
- .github\workflows\deploy.yml
- .gitignore
- components\__init__.py
- components\height_analytics.py
- components\recent_runs.py
- components\session_analytics.py
- components\tower_analytics.py
- config.py
- database.py
- DATABASE_HISTORY.md
- dist\.last_build_id
- dist\app.tar.gz
- dist\assets\AssetManifest.bin
- dist\assets\AssetManifest.bin.json
- dist\assets\AssetManifest.json
- dist\assets\FontManifest.json
- dist\assets\fonts\MaterialIcons-Regular.otf
- dist\assets\NOTICES
- dist\assets\packages\cupertino_icons\assets\CupertinoIcons.ttf
- dist\assets\packages\media_kit\assets\web\hls1.4.10.js
- dist\assets\packages\record_web\assets\js\record.fixwebmduration.js
- dist\assets\packages\record_web\assets\js\record.worklet.js
- dist\assets\packages\wakelock_plus\assets\no_sleep.js
- dist\assets\packages\window_manager\images\ic_chrome_close.png
- dist\assets\packages\window_manager\images\ic_chrome_maximize.png
- dist\assets\packages\window_manager\images\ic_chrome_minimize.png
- dist\assets\packages\window_manager\images\ic_chrome_unmaximize.png
- dist\assets\shaders\ink_sparkle.frag
- dist\favicon.png
- dist\flutter.js
- dist\flutter_bootstrap.js
- dist\flutter_service_worker.js
- dist\icons\apple-touch-icon-192.png
- dist\icons\icon-192.png
- dist\icons\icon-512.png
- dist\icons\icon-maskable-192.png
- dist\icons\icon-maskable-512.png
- dist\icons\loading-animation.png
- dist\index.html
- dist\main.dart.js
- dist\manifest.json
- dist\python-worker.js
- dist\python.js
- dist\version.json
- engine.py
- main.py
- MCSRTracker.spec
- requirements.txt

==================================================

--- START OF FILE: components\__init__.py ---

--- END OF FILE: components\__init__.py ---

--- START OF FILE: components\height_analytics.py ---
import flet as ft
import database

class HeightAnalytics(ft.UserControl):
    def __init__(self):
        super().__init__()
        self.view_mode = "list" # list or detail
        self.current_height = None
        self.all_runs = []
        self.active_types = set()
        self.active_towers = set() 
        
        # State
        self.detail_sort_option = "Newest"
        self.list_sort_option = "Height"
        self.list_sort_column_index = 0
        self.list_sort_ascending = True
        self.chart_mode = "expl" 
        self.hide_failures = False
        self.show_trend = False
        self.group_size = 1
        self.height_list = [] # Sorted heights for navigation
        
        self.main_container = ft.Container(expand=True)

    def build(self):
        self._build_list()
        return self.main_container

    def show_list(self):
        self._build_list()
        self.update()

    def _build_list(self):
        self.view_mode = "list"
        self.current_height = None
        
        # Get stats: (height, count, min_time, min_expl)
        raw_stats = database.get_height_stats()
        
        height_data = []
        for h, count, best_time, best_expl in raw_stats:
            runs = database.get_runs_by_height(h)
            
            avg_time = 0
            avg_expl = 0
            
            valid_time_runs = [r for r in runs if r[2] > 0]
            if valid_time_runs:
                avg_time = sum(r[2] for r in valid_time_runs) / len(valid_time_runs)
                
            if runs:
                avg_expl = sum(r[4] for r in runs) / len(runs)
                
            height_data.append({
                "height": h,
                "count": count,
                "best_time": best_time,
                "avg_time": avg_time,
                "best_expl": best_expl,
                "avg_expl": avg_expl
            })

        # Sort Logic
        col_keys = ["height", "count", "best_expl", "avg_expl", "best_time", "avg_time"]
        
        # Sync index with option if changed via dropdown
        if hasattr(self, '_last_sort_from_dropdown') and self._last_sort_from_dropdown:
            if self.list_sort_option == "Height": self.list_sort_column_index = 0
            elif self.list_sort_option == "Most Runs": self.list_sort_column_index = 1
            elif self.list_sort_option == "Best Expl": self.list_sort_column_index = 2
            elif self.list_sort_option == "Best Time": self.list_sort_column_index = 4
            self._last_sort_from_dropdown = False
            self.list_sort_ascending = (self.list_sort_option != "Most Runs")

        key = col_keys[self.list_sort_column_index]
        height_data.sort(key=lambda x: x[key], reverse=not self.list_sort_ascending)
        
        self.height_list = [d['height'] for d in height_data]

        rows = []
        for d in height_data:
            rows.append(ft.DataRow(
                cells=[
                    ft.DataCell(ft.Text(str(d['height']))),
                    ft.DataCell(ft.Text(str(d['count']), color="grey")),
                    ft.DataCell(ft.Text(str(d['best_expl']), color=ft.colors.CYAN_400)),
                    ft.DataCell(ft.Text(f"{d['avg_expl']:.1f}")),
                    ft.DataCell(ft.Text(f"{d['best_time']:.2f}s", color=ft.colors.AMBER_400 if d['best_time'] > 0 else "grey")),
                    ft.DataCell(ft.Text(f"{d['avg_time']:.2f}s")),
                ],
                on_select_changed=lambda e, h=d['height']: self.show_detail(h)
            ))

        data_table = ft.DataTable(
            columns=[
                ft.DataColumn(ft.Text("Height", weight="bold"), on_sort=self.on_list_sort, numeric=True),
                ft.DataColumn(ft.Text("Suc. Runs"), on_sort=self.on_list_sort, numeric=True),
                ft.DataColumn(ft.Text("Best Expl"), on_sort=self.on_list_sort, numeric=True),
                ft.DataColumn(ft.Text("Avg Expl"), on_sort=self.on_list_sort, numeric=True),
                ft.DataColumn(ft.Text("Best Time"), on_sort=self.on_list_sort, numeric=True),
                ft.DataColumn(ft.Text("Avg Time"), on_sort=self.on_list_sort, numeric=True),
            ],
            rows=rows,
            sort_column_index=self.list_sort_column_index,
            sort_ascending=self.list_sort_ascending,
            heading_row_color=ft.colors.BLACK54,
            heading_row_height=40,
            data_row_min_height=40,
            column_spacing=20,
            show_checkbox_column=False,
        )

        sort_dropdown = ft.Dropdown(
            width=140, text_size=12, value=self.list_sort_option,
            options=[
                ft.dropdown.Option("Height"),
                ft.dropdown.Option("Most Runs"),
                ft.dropdown.Option("Best Expl"),
                ft.dropdown.Option("Best Time"),
            ],
            on_change=self.on_list_sort_dropdown_change, content_padding=5
        )

        header_row = ft.Row([
            ft.Text("Height Analytics", size=20, weight="bold"),
            ft.Container(expand=True),
            ft.Text("Sort: ", size=12, color="grey"),
            sort_dropdown
        ])
        
        self.main_container.content = ft.Column([
            header_row,
            ft.Divider(),
            ft.Container(
                content=ft.Column([
                    ft.Row([data_table], alignment=ft.MainAxisAlignment.START)
                ], scroll=ft.ScrollMode.ADAPTIVE),
                expand=True
            )
        ], expand=True)

    def on_list_sort(self, e):
        self.list_sort_column_index = e.column_index
        self.list_sort_ascending = e.ascending
        
        # Update dropdown value to match if possible
        col_to_opt = {0: "Height", 1: "Most Runs", 2: "Best Expl", 4: "Best Time"}
        if e.column_index in col_to_opt:
            self.list_sort_option = col_to_opt[e.column_index]
            
        self._last_sort_from_header = True
        self.show_list()

    def on_list_sort_dropdown_change(self, e):
        self.list_sort_option = e.control.value
        self._last_sort_from_dropdown = True
        self.show_list()

    def show_detail(self, height):
        self.view_mode = "detail"
        self.current_height = height
        self.all_runs = database.get_runs_by_height(height)
        
        # Populate filter sets
        self.active_types = set(r[6] for r in self.all_runs if r[6] and r[6] != "Unknown")
        self.active_towers = set(r[5] for r in self.all_runs if r[5] and r[5] != "Unknown")
        
        # Build relationship maps for propagation
        self.tower_to_types = {}
        self.type_to_towers = {}
        for r in self.all_runs:
            t, rt = r[5], r[6]
            if t not in self.tower_to_types: self.tower_to_types[t] = set()
            self.tower_to_types[t].add(rt)
            if rt not in self.type_to_towers: self.type_to_towers[rt] = set()
            self.type_to_towers[rt].add(t)

        # --- UI CONTROLS ---
        height_index = self.height_list.index(height) if height in self.height_list else -1
        
        nav_header = ft.Row([
            ft.IconButton(ft.icons.ARROW_BACK, tooltip="Back to Comparison", on_click=lambda e: self.show_list()),
            ft.Container(width=10),
            ft.IconButton(
                ft.icons.CHEVRON_LEFT, 
                tooltip="Next Height (Up)",
                disabled=(height_index <= 0), 
                on_click=lambda e: self.show_detail(self.height_list[height_index - 1])
            ),
            ft.IconButton(
                ft.icons.CHEVRON_RIGHT, 
                tooltip="Prev Height (Down)",
                disabled=(height_index == -1 or height_index >= len(self.height_list) - 1), 
                on_click=lambda e: self.show_detail(self.height_list[height_index + 1])
            ),
            ft.Container(width=10),
            ft.Text(f"Height {height}", size=24, weight="bold"),
        ], alignment=ft.MainAxisAlignment.START)
        
        # Filters Containers
        self.filter_container_types = ft.Row(wrap=True)
        self.filter_container_towers = ft.Row(wrap=True)
        
        # Tower filters scrollable box
        tower_scroll = ft.Container(
             content=ft.Column([self.filter_container_towers], scroll=ft.ScrollMode.AUTO),
             height=100, border=ft.border.all(1, ft.colors.GREY_800),
             border_radius=5, padding=5
        )

        # Controls
        self.chart_toggle = ft.SegmentedButton(
            selected={self.chart_mode}, show_selected_icon=False,
            segments=[
                ft.Segment(value="expl", label=ft.Text("Explosives")),
                ft.Segment(value="time", label=ft.Text("Time")),
            ],
            on_change=self.on_chart_mode_change
        )
        self.trend_button = ft.IconButton(
            icon=ft.icons.TIMELINE,
            icon_color="white",
            selected_icon=ft.icons.TIMELINE,
            selected_icon_color="cyan",
            selected=self.show_trend,
            tooltip="Toggle Trend Line",
            on_click=self.on_trend_click
        )
        self.group_input = ft.TextField(
            label="Group", value=str(self.group_size), width=60, 
            text_size=12, content_padding=5, keyboard_type=ft.KeyboardType.NUMBER,
            on_submit=self.on_group_submit, on_blur=self.on_group_submit
        )
        self.detail_sort_dropdown = ft.Dropdown(
            width=100, text_size=12, value=self.detail_sort_option,
            options=[
                ft.dropdown.Option("Newest"),
                ft.dropdown.Option("Oldest"),
                ft.dropdown.Option("Best Expl"),
                ft.dropdown.Option("Best Time"),
            ],
            on_change=self.on_detail_sort_change, content_padding=5
        )
        
        controls_row = ft.Row([
            self.chart_toggle, ft.Container(width=10),
            self.trend_button, self.group_input,
            ft.Container(expand=True),
            self.detail_sort_dropdown
        ])
        
        self.chart_container = ft.Container(height=300, padding=10, bgcolor=ft.colors.BLACK54, border_radius=8)
        self.stats_container = ft.Row(alignment=ft.MainAxisAlignment.SPACE_AROUND)
        self.list_container = ft.Column(scroll=ft.ScrollMode.AUTO, expand=True)

        list_header = ft.Container(
            content=ft.Row([
                ft.Text("Expl", width=50, weight="bold", color="grey"),
                ft.Text("Time", width=100, weight="bold", color="grey"),
                ft.Text("Bed", width=60, weight="bold", color="grey"),
                ft.Text("Tower", width=80, weight="bold", color="grey"),
                ft.Text("Type", expand=True, weight="bold", color="grey"),
                ft.Text("Date", width=120, weight="bold", color="grey"),
            ]),
            padding=ft.padding.only(left=5, bottom=5)
        )

        self.main_container.content = ft.Column([
            nav_header,
            # Unified All/None
            ft.Row([
                ft.Text("Filters", weight="bold"),
                ft.TextButton("All", on_click=lambda _: self.toggle_all_unified(True), style=ft.ButtonStyle(padding=5)),
                ft.TextButton("None", on_click=lambda _: self.toggle_all_unified(False), style=ft.ButtonStyle(padding=5)),
            ], spacing=20),
            
            # Tower Filters (First)
            ft.Row([ft.Text("Towers:", size=12, color="grey"), self.filter_container_towers], wrap=True),
            
            # Type Filters (Second)
            ft.Row([ft.Text("Types:", size=12, color="grey"), self.filter_container_types], wrap=True),
            
            ft.Container(height=10),
            controls_row,
            self.chart_container,
            ft.Divider(height=10, color="transparent"),
            self.stats_container,
            ft.Divider(),
            ft.Row([ft.Text("Run History", weight="bold"), ft.Container(expand=True)]),
            list_header,
            self.list_container
        ], expand=True)
        
        self._build_type_filters()
        self._build_tower_filters()
        self._refresh_detail_content()
        self.update()

    def _build_type_filters(self):
        controls = []
        all_types = sorted(list(self.type_to_towers.keys()))
        for t in all_types:
            is_active = t in self.active_types
            btn = self._make_filter_chip(t, is_active, lambda e, x=t: self.toggle_type(x))
            controls.append(btn)
        self.filter_container_types.controls = controls
        
    def _build_tower_filters(self):
        controls = []
        all_towers = sorted(list(self.tower_to_types.keys()))
        for t in all_towers:
            is_active = t in self.active_towers
            btn = self._make_filter_chip(t, is_active, lambda e, x=t: self.toggle_tower(x))
            controls.append(btn)
        self.filter_container_towers.controls = controls

    def _make_filter_chip(self, label, active, on_click):
        bg = ft.colors.BLUE_700 if active else ft.colors.TRANSPARENT
        border = ft.colors.BLUE_700 if active else ft.colors.GREY_700
        return ft.Container(
            content=ft.Text(label, size=12, color="white" if active else "grey"),
            padding=5, border_radius=12, bgcolor=bg, border=ft.border.all(1, border),
            ink=True, on_click=on_click
        )

    def toggle_type(self, val):
        if val in self.active_types:
            self.active_types.remove(val)
            for tower in self.type_to_towers.get(val, []):
                if tower in self.active_towers:
                    if not any(rt in self.active_types for rt in self.tower_to_types.get(tower, [])):
                        self.active_towers.remove(tower)
        else:
            self.active_types.add(val)
            for tower in self.type_to_towers.get(val, []):
                self.active_towers.add(tower)
        self._build_type_filters(); self._build_tower_filters(); self._refresh_detail_content(); self.update()

    def toggle_tower(self, val):
        if val in self.active_towers:
            self.active_towers.remove(val)
            for rtype in self.tower_to_types.get(val, []):
                if rtype in self.active_types:
                    if not any(t in self.active_towers for t in self.type_to_towers.get(rtype, [])):
                        self.active_types.remove(rtype)
        else:
            self.active_towers.add(val)
            for rtype in self.tower_to_types.get(val, []):
                self.active_types.add(rtype)
        self._build_type_filters(); self._build_tower_filters(); self._refresh_detail_content(); self.update()

    def toggle_all_unified(self, active):
        if active:
            self.active_types = set(self.type_to_towers.keys())
            self.active_towers = set(self.tower_to_types.keys())
        else:
            self.active_types = set(); self.active_towers = set()
        self._build_type_filters(); self._build_tower_filters(); self._refresh_detail_content(); self.update()

    def on_chart_mode_change(self, e):
        self.chart_mode = list(e.control.selected)[0]
        self._refresh_detail_content(); self.update()

    def on_detail_sort_change(self, e):
        self.detail_sort_option = self.detail_sort_dropdown.value
        self._refresh_detail_content(); self.update()

    def on_trend_click(self, e):
        self.show_trend = not self.show_trend
        self.trend_button.selected = self.show_trend
        self.trend_button.update()
        self._refresh_detail_content(); self.update()

    def on_group_submit(self, e):
        try:
            val = int(e.control.value)
            if val < 1: val = 1
            self.group_size = val
        except:
            self.group_size = 1; e.control.value="1"; e.control.update()
        self._refresh_detail_content(); self.update()

    def _refresh_detail_content(self):
        filtered_runs = [r for r in self.all_runs if r[6] in self.active_types and r[5] in self.active_towers]
        success_count = len(filtered_runs)
        avg_expl_val = 0; avg_time_val = 0; best_expl_val = 0; best_time_val = 0
        if success_count > 0:
            avg_expl_val = sum(r[4] for r in filtered_runs) / success_count
            best_expl_val = min(r[4] for r in filtered_runs)
            valid_time_runs = [r for r in filtered_runs if r[2] > 0]
            if valid_time_runs:
                avg_time_val = sum(r[2] for r in valid_time_runs) / len(valid_time_runs)
                best_time_val = min(r[2] for r in valid_time_runs)
            
        self.stats_container.controls = [
            ft.Column([ft.Text("Suc. Runs", color="grey"), ft.Text(f"{success_count}", size=20, weight="bold")], horizontal_alignment=ft.CrossAxisAlignment.CENTER),
            ft.VerticalDivider(width=20, color="grey"),
            ft.Row([
                ft.Column([ft.Text("Best Expl", color="grey", size=12), ft.Text(f"{best_expl_val}", size=16, weight="bold", color=ft.colors.CYAN_400)], horizontal_alignment=ft.CrossAxisAlignment.CENTER),
                ft.Column([ft.Text("Avg Expl", color="grey", size=12), ft.Text(f"{avg_expl_val:.2f}", size=16, weight="bold")], horizontal_alignment=ft.CrossAxisAlignment.CENTER),
            ], spacing=20),
            ft.VerticalDivider(width=20, color="grey"),
            ft.Row([
                 ft.Column([ft.Text("Best Time", color="grey", size=12), ft.Text(f"{best_time_val:.2f}s", size=16, weight="bold", color=ft.colors.AMBER_400)], horizontal_alignment=ft.CrossAxisAlignment.CENTER),
                ft.Column([ft.Text("Avg Time", color="grey", size=12), ft.Text(f"{avg_time_val:.2f}s", size=16, weight="bold")], horizontal_alignment=ft.CrossAxisAlignment.CENTER),
            ], spacing=20),
        ]
        self._build_chart(filtered_runs)
        self._build_run_list(filtered_runs)
        
    def _build_chart(self, successes):
        chart_data_source = sorted(successes, key=lambda x: x[1])
        y_values = []
        if self.chart_mode == "expl":
            y_values = [r[4] for r in chart_data_source if r[4] > 0]
            y_title = "Explosives"; chart_color = ft.colors.CYAN_400
        else:
            y_values = [r[2] for r in chart_data_source]
            y_title = "Time (s)"; chart_color = ft.colors.PURPLE_400
            
        points = []
        final_y_values = [] 
        if self.group_size > 1:
            for i in range(0, len(y_values), self.group_size):
                chunk = y_values[i : i + self.group_size]
                if chunk:
                    avg = sum(chunk) / len(chunk)
                    points.append(ft.LineChartDataPoint(x=i, y=avg))
                    final_y_values.append((i, avg))
        else:
            for i, val in enumerate(y_values):
                points.append(ft.LineChartDataPoint(x=i, y=val))
                final_y_values.append((i, val))
                
        data_series = [ft.LineChartData(data_points=points, stroke_width=2, color=chart_color, curved=True, stroke_cap_round=True, below_line_bgcolor=ft.colors.with_opacity(0.1, chart_color))]
        
        if self.show_trend and len(final_y_values) > 1:
            n = len(final_y_values); sum_x = sum(x for x, y in final_y_values); sum_y = sum(y for x, y in final_y_values); sum_xy = sum(x*y for x, y in final_y_values); sum_xx = sum(x*x for x, y in final_y_values); denom = (n * sum_xx - sum_x * sum_x)
            if denom != 0:
                m = (n * sum_xy - sum_x * sum_y) / denom; b = (sum_y - m * sum_x) / n; start_x = final_y_values[0][0]; end_x = final_y_values[-1][0]
                data_series.append(ft.LineChartData(data_points=[ft.LineChartDataPoint(x=start_x, y=m*start_x + b), ft.LineChartDataPoint(x=end_x, y=m*end_x + b)], stroke_width=2, color=ft.colors.WHITE54, dash_pattern=[5, 5], curved=False))

        self.chart_container.content = ft.LineChart(data_series=data_series, border=ft.border.all(1, ft.colors.GREY_800), left_axis=ft.ChartAxis(labels_size=30, title=ft.Text(y_title, size=10)), bottom_axis=ft.ChartAxis(title=ft.Text(f"Runs", size=10), labels_size=0), tooltip_bgcolor=ft.colors.GREY_800, expand=True)

    def _build_run_list(self, runs):
        sorted_runs = list(runs)
        if self.detail_sort_option == "Newest": sorted_runs.sort(key=lambda x: (x[1], x[0]), reverse=True)
        elif self.detail_sort_option == "Oldest": sorted_runs.sort(key=lambda x: (x[1], x[0]), reverse=False)
        elif self.detail_sort_option == "Best Expl": sorted_runs.sort(key=lambda x: x[4], reverse=False)
        elif self.detail_sort_option == "Best Time": sorted_runs.sort(key=lambda x: x[2] if x[2] > 0 else 999, reverse=False)

        list_rows = []
        for run in sorted_runs:
            row = ft.Container(
                content=ft.Row([
                    ft.Text(f"{run[3]}", width=50, weight="bold", color=ft.colors.CYAN_200, size=16),
                    ft.Text(f"{run[2]:.2f}s", width=100, weight="bold"),
                    ft.Text(f"{run[8]:.2f}s" if run[8] else "-", width=60, color=ft.colors.ORANGE_300),
                    ft.Text(f"{run[5]}", width=80, color="grey"),
                    ft.Text(f"{run[6]}", expand=True, size=14),
                    ft.Text(run[1], width=120, size=12, color="grey")
                ]),
                padding=10, border=ft.border.only(bottom=ft.border.BorderSide(1, "#333333"))
            )
            list_rows.append(row)
        self.list_container.controls = list_rows

--- END OF FILE: components\height_analytics.py ---

--- START OF FILE: components\recent_runs.py ---
import flet as ft
import database
import config
from datetime import datetime

def get_view(page, on_run_click=None):
    # Load persisted state
    cfg = config.load_config(page)
    init_chart_mode = cfg.get("chart_mode", "expl")
    init_hide_fails = cfg.get("hide_fails", False)

    # --- UI Elements ---
    chart_container = ft.Container(height=150, bgcolor=ft.colors.BLACK54, border_radius=8, padding=10)
    
    table = ft.DataTable(
        columns=[
            ft.DataColumn(ft.Text("Expl")),
            ft.DataColumn(ft.Text("Time")),
            ft.DataColumn(ft.Text("Bed")),
            ft.DataColumn(ft.Text("Tower")),
            ft.DataColumn(ft.Text("Type")),
            ft.DataColumn(ft.Text("Y")), # Height
            ft.DataColumn(ft.Text("Date")),
        ],
        rows=[],
        column_spacing=10,
        data_row_min_height=35,
        heading_row_height=30,
        show_checkbox_column=False,
    )

    # Scrollable area — ONLY the table goes here
    table_scroll = ft.ListView(expand=True, spacing=0)
    table_scroll.controls = [
        ft.Container(content=table, padding=ft.padding.only(top=5))
    ]

    # --- Controls ---
    def on_chart_change(e):
        new_mode = list(e.control.selected)[0]
        config.save_config(page, {"chart_mode": new_mode})
        update_table(outer_column)

    chart_mode_segment = ft.SegmentedButton(
        selected={init_chart_mode},
        show_selected_icon=False,
        segments=[
            ft.Segment(value="expl", label=ft.Text("Explosives")),
            ft.Segment(value="time", label=ft.Text("Time")),
        ],
        on_change=on_chart_change
    )

    group_input = ft.TextField(
        label="Group", value="1", width=80, text_size=12,
        keyboard_type=ft.KeyboardType.NUMBER,
        on_submit=lambda e: update_table(outer_column)
    )

    def on_trend_click(e):
        trend_button.selected = not trend_button.selected
        config.save_config(page, {"show_trend": trend_button.selected})
        trend_button.update()
        update_table(outer_column)

    trend_button = ft.IconButton(
        icon=ft.icons.TIMELINE,
        icon_color="white",
        selected_icon=ft.icons.TIMELINE,
        selected_icon_color="cyan",
        selected=cfg.get("show_trend", False),
        tooltip="Toggle Trend Line",
        on_click=on_trend_click
    )

    def on_fail_click(e):
        fail_button.selected = not fail_button.selected
        config.save_config(page, {"hide_fails": fail_button.selected})
        fail_button.update()
        update_table(outer_column)

    fail_button = ft.IconButton(
        icon=ft.icons.FILTER_ALT_OFF,
        icon_color="white",
        selected_icon=ft.icons.FILTER_ALT,
        selected_icon_color="red",
        selected=init_hide_fails,
        tooltip="Hide Fails",
        on_click=on_fail_click
    )

    # Fixed header (not scrollable)
    header_row = ft.Row([
        ft.Text("Recent History", size=20, weight="bold"),
        ft.Container(expand=True),
        trend_button,
        fail_button,
        group_input,
        chart_mode_segment,
    ], alignment=ft.MainAxisAlignment.START, spacing=15)

    # Outer layout: fixed header + chart on top, scrollable table below
    outer_column = ft.Column([
        header_row,
        chart_container,
        table_scroll,
    ], expand=True, spacing=10)

    # Store references on outer_column for update_table / set_width
    outer_column.table_ref = table
    outer_column.chart_ref = chart_container
    outer_column.chart_mode_ref = chart_mode_segment
    outer_column.group_ref = group_input
    outer_column.trend_ref = trend_button
    outer_column.fail_ref = fail_button
    outer_column.on_run_click_callback = on_run_click
    
    return outer_column, outer_column

def toggle_icon_button(e, main_control):
    e.control.selected = not e.control.selected
    e.control.update()
    update_table(main_control)

def set_width(main_control, width):
    main_control.current_width = width
    update_table(main_control)

def update_table(main_control):
    table = main_control.table_ref
    chart_container = main_control.chart_ref
    chart_mode = list(main_control.chart_mode_ref.selected)[0]
    hide_fails = main_control.fail_ref.selected
    show_trend = main_control.trend_ref.selected
    
    # Calculate Scale
    current_w = getattr(main_control, 'current_width', 450)
    # Less aggressive scaling: maxing out around 1.4x at 800px width
    # 450px -> 1.0
    # 800px -> 1.0 + (350 * 0.0011) ≈ 1.385
    ratio = (current_w - 450.0) * 0.0011
    scale = 1.0 + ratio
    
    if scale < 1.0: scale = 1.0
    if scale > 1.4: scale = 1.4
    
    # Font Sizes
    s_expl = 13 * scale
    s_time = 13 * scale
    s_bed = 12 * scale
    s_other = 11 * scale
    s_date = 10 * scale
    
    try:
        group_size = int(main_control.group_ref.value)
        if group_size < 1: group_size = 1
    except:
        group_size = 1

    all_runs = database.get_recent_runs(limit=100) # Get more to allow for filtering
    
    # --- TABLE LOGIC ---
    new_rows = []
    pb_map = database.get_pbs_map()
    
    # We display the last 50 *visible* runs
    visible_count = 0
    for run in all_runs:
        if visible_count >= 50: break
        
        is_success = bool(run[9])
        if hide_fails and not is_success:
            continue
            
        visible_count += 1
        ts_str = run[1]
        time_val = run[2]
        expl_str = run[3]
        total_expl = run[4]
        tower = run[5]
        r_type = run[6]
        height = run[7]
        bed = run[8]

        try:
            dt = datetime.strptime(ts_str, "%Y-%m-%d %H:%M:%S")
            date_display = dt.strftime("%m/%d %H:%M")
        except:
            date_display = ts_str

        row_color = "white"
        if not is_success:
            row_color = ft.colors.RED_400
            # Show fail reason in Expl column
            fail_reason = run[10] if run[10] else "Fail"
            expl_display = fail_reason
            bed_display = "-"
            time_display = f"{time_val:.1f}s"
            tower_display = tower if tower != "Unknown" else "-"
            type_display = r_type if r_type != "Unknown" else "-"
            height_display = "-"
        else:
            expl_display = expl_str
            time_display = f"{time_val:.2f}s"
            bed_display = f"{bed:.2f}s" if bed else "-"
            tower_display = tower
            type_display = r_type
            height_display = str(height) if height > 0 else "-"
            
            key = (tower, r_type)
            if key in pb_map and total_expl == pb_map[key]:
                row_color = ft.colors.YELLOW_400

        def on_row_click(e, t=tower, rt=r_type):
            if hasattr(main_control, 'on_run_click_callback') and main_control.on_run_click_callback:
                if t != "Unknown":
                    main_control.on_run_click_callback(t, rt)

        new_rows.append(
            ft.DataRow(
                on_select_changed=on_row_click,
                cells=[
                    ft.DataCell(ft.Text(expl_display, color=row_color, weight="bold", size=s_expl, no_wrap=True, overflow=ft.TextOverflow.ELLIPSIS)),
                    ft.DataCell(ft.Text(time_display, color=row_color, size=s_time, no_wrap=True)),
                    ft.DataCell(ft.Text(bed_display, size=s_bed, color=ft.colors.ORANGE_300 if bed else "grey", no_wrap=True)),
                    ft.DataCell(ft.Text(tower_display, size=s_other, no_wrap=True, overflow=ft.TextOverflow.ELLIPSIS)),
                    ft.DataCell(ft.Text(type_display, size=s_other, no_wrap=True, overflow=ft.TextOverflow.ELLIPSIS)),
                    ft.DataCell(ft.Text(height_display, size=s_other, no_wrap=True)),
                    ft.DataCell(ft.Text(date_display, size=s_date, color="grey", no_wrap=True)),
                ]
            )
        )
    table.rows = new_rows
    table.update()

    # --- CHART LOGIC ---
    # Process successes for the graph
    chart_data_source = [r for r in reversed(all_runs) if r[9]]
    
    y_values = []
    if chart_mode == "expl":
        y_values = [r[4] for r in chart_data_source if r[4] > 0]
        chart_color = ft.colors.CYAN_400
        title_text = "Expl."
    else:
        y_values = [r[2] for r in chart_data_source]
        chart_color = ft.colors.PURPLE_400
        title_text = "Time"

    points = []
    final_coords = []
    if group_size > 1:
        for i in range(0, len(y_values), group_size):
            chunk = y_values[i : i + group_size]
            if chunk:
                avg = sum(chunk) / len(chunk)
                points.append(ft.LineChartDataPoint(x=i, y=avg))
                final_coords.append((i, avg))
    else:
        for i, val in enumerate(y_values):
            points.append(ft.LineChartDataPoint(x=i, y=val))
            final_coords.append((i, val))

    data_series = [
        ft.LineChartData(
            data_points=points,
            stroke_width=2,
            color=chart_color,
            curved=True,
            stroke_cap_round=True,
            below_line_bgcolor=ft.colors.with_opacity(0.1, chart_color),
        )
    ]

    # Trend Line
    if show_trend and len(final_coords) > 1:
        n = len(final_coords)
        sum_x = sum(x for x, y in final_coords); sum_y = sum(y for x, y in final_coords); sum_xy = sum(x*y for x, y in final_coords); sum_xx = sum(x*x for x, y in final_coords)
        denom = (n * sum_xx - sum_x * sum_x)
        if denom != 0:
            m = (n * sum_xy - sum_x * sum_y) / denom; b = (sum_y - m * sum_x) / n
            start_x, end_x = final_coords[0][0], final_coords[-1][0]
            data_series.append(ft.LineChartData(
                data_points=[ft.LineChartDataPoint(x=start_x, y=m*start_x+b), ft.LineChartDataPoint(x=end_x, y=m*end_x+b)],
                stroke_width=1, color=ft.colors.WHITE54, dash_pattern=[5, 5]
            ))

    chart = ft.LineChart(
        data_series=data_series,
        border=ft.border.all(1, ft.colors.GREY_800),
        left_axis=ft.ChartAxis(
            labels_size=40, 
            title=ft.Text(title_text, size=10),
            show_labels=True
        ),
        bottom_axis=ft.ChartAxis(labels_size=0),
        tooltip_bgcolor=ft.colors.GREY_800,
        expand=True
    )
    chart_container.content = chart
    chart_container.update()
--- END OF FILE: components\recent_runs.py ---

--- START OF FILE: components\session_analytics.py ---
import flet as ft
import database
import config
from datetime import datetime, timedelta

class SessionAnalytics(ft.UserControl):
    def __init__(self):
        super().__init__()
        self.view_mode = "list"
        self.session_list = [] 
        self.current_session_index = -1
        self.session_data = None
        
        self.main_container = ft.Container(expand=True)
        
        # Detail View State (Persisted)
        self.detail_runs = []
        self.chart_mode = "expl"
        self.show_trend = False
        self.hide_failures = False
        self.hide_world_loads = False 
        self.group_size = 1
        self.sort_option = "Newest" 
        
        # List View State
        self.show_splits_only = False 

    def did_mount(self):
        # Load persisted state after mount so page is available
        cfg = config.load_config(self.page)
        self.show_splits_only = cfg.get("show_splits_only", False)
        self.splits_button.selected = self.show_splits_only
        self._build_list_view()
        self.update()

    def build(self):
        self._build_list_view()
        return self.main_container

    # --- LIST VIEW ---
    def _build_list_view(self):
        self.view_mode = "list"
        self.session_list = database.get_session_index()
        
        # Filter Logic for "Splits Only"
        display_list = self.session_list
        if self.show_splits_only:
            display_list = [s for s in self.session_list if s['type'] == 'split']
        
        list_rows = []
        for i, sess in enumerate(display_list):
            # Map index back to original list for clicking
            original_index = self.session_list.index(sess)
            
            # Duration
            try:
                start = datetime.strptime(sess['start_time'], "%Y-%m-%d %H:%M:%S")
                end = datetime.strptime(sess['end_time'], "%Y-%m-%d %H:%M:%S")
                duration = end - start
                dur_str = str(duration).split('.')[0]
            except:
                dur_str = "0:00:00"

            total = sess['count']
            success = sess['success_count']
            rate = (success / total * 100) if total > 0 else 0.0
            
            rate_color = ft.colors.RED_400
            if rate > 30: rate_color = ft.colors.ORANGE_400
            if rate > 70: rate_color = ft.colors.GREEN_400

            icon = ft.icons.FOLDER if sess['type'] == 'file' else ft.icons.TIMER
            icon_color = ft.colors.BLUE_400 if sess['type'] == 'file' else ft.colors.ORANGE_400
            
            row = ft.Container(
                content=ft.Row([
                    ft.Row([
                        ft.Icon(icon, color=icon_color, size=20),
                        ft.Column([
                            ft.Text(sess['id'], weight="bold", size=14, width=280, no_wrap=True),
                            ft.Text(f"{sess['start_time']} • {dur_str}", size=11, color="grey")
                        ], spacing=2),
                    ]),
                    
                    ft.Container(expand=True),
                    
                    ft.Row([
                        ft.Column([
                            ft.Text("Runs", size=10, color="grey"),
                            ft.Text(f"{total}", weight="bold", size=14),
                        ], horizontal_alignment="center"),
                        ft.Container(width=10),
                        ft.Column([
                            ft.Text("Success %", size=10, color="grey"),
                            ft.Text(f"{rate:.1f}%", weight="bold", size=14, color=rate_color),
                        ], horizontal_alignment="center", width=70),
                        ft.Icon(ft.icons.CHEVRON_RIGHT, color="grey")
                    ], alignment=ft.MainAxisAlignment.END)
                ], alignment=ft.MainAxisAlignment.SPACE_BETWEEN),
                padding=10,
                border_radius=5,
                bgcolor=ft.colors.GREY_900,
                ink=True,
                on_click=lambda e, idx=original_index: self.load_session_detail(idx)
            )
            list_rows.append(row)

        # Header with Toggle
        self.splits_button = ft.IconButton(
            icon=ft.icons.TIMER_OUTLINED,
            icon_color="white",
            selected_icon=ft.icons.TIMER,
            selected_icon_color="orange",
            selected=self.show_splits_only,
            tooltip="Splits Only",
            on_click=self.on_splits_click
        )

        header = ft.Row([
            ft.Text("Session History", size=20, weight="bold"),
            ft.Row([
                self.splits_button,
            ])
        ], alignment=ft.MainAxisAlignment.SPACE_BETWEEN)

        self.main_container.content = ft.Column([
            header,
            ft.Divider(),
            ft.ListView(controls=list_rows, expand=True, spacing=5)
        ], expand=True)

    def on_splits_click(self, e):
        self.show_splits_only = not self.show_splits_only
        self.splits_button.selected = self.show_splits_only
        
        # Persist
        config.save_config(self.page, {"show_splits_only": self.show_splits_only})
        
        self.splits_button.update()
        self._build_list_view()
        self.update()

    def refresh_list(self):
        self._build_list_view()
        self.update()

    # --- DETAIL VIEW (Unchanged Logic, just re-stating for completeness) ---
    def load_session_detail(self, index):
        if index < 0 or index >= len(self.session_list):
            return
            
        self.view_mode = "detail"
        self.current_session_index = index
        self.session_data = self.session_list[index]
        
        self.detail_runs = database.get_runs_by_session(self.session_data['id'], self.session_data['type'])
        
        # Header with Nav
        nav_row = ft.Row([
            ft.IconButton(ft.icons.ARROW_BACK, tooltip="Back to List", on_click=lambda e: self.show_list()),
            ft.Container(width=10),
            ft.IconButton(
                ft.icons.CHEVRON_LEFT, 
                tooltip="Next Session (Newer)",
                disabled=(index == 0), 
                on_click=lambda e: self.load_session_detail(index - 1)
            ),
             ft.IconButton(
                ft.icons.CHEVRON_RIGHT, 
                tooltip="Prev Session (Older)",
                disabled=(index >= len(self.session_list) - 1), 
                on_click=lambda e: self.load_session_detail(index + 1)
            ),
            ft.Container(width=20),
            ft.Column([
                ft.Text(self.session_data['id'], size=18, weight="bold", no_wrap=True),
                ft.Text(f"{self.session_data['start_time']}", color="grey", size=12)
            ], spacing=0, alignment=ft.MainAxisAlignment.CENTER)
        ], alignment=ft.MainAxisAlignment.START)

        # Controls
        self.chart_toggle = ft.SegmentedButton(
            selected={self.chart_mode},
            show_selected_icon=False,
            segments=[
                ft.Segment(value="expl", label=ft.Text("Expl")),
                ft.Segment(value="time", label=ft.Text("Time")),
            ],
            on_change=self.on_chart_mode_change
        )
        
        self.trend_button = ft.IconButton(
            icon=ft.icons.TIMELINE,
            icon_color="white",
            selected_icon=ft.icons.TIMELINE,
            selected_icon_color="cyan",
            selected=self.show_trend,
            tooltip="Toggle Trend Line",
            on_click=self.on_trend_click
        )
        
        self.group_input = ft.TextField(
            label="Group", value=str(self.group_size), width=60, text_size=12, content_padding=5,
            keyboard_type=ft.KeyboardType.NUMBER, on_submit=self.on_group_submit, on_blur=self.on_group_submit
        )

        self.sort_dropdown = ft.Dropdown(
            width=120,
            text_size=12,
            value=self.sort_option,
            options=[
                ft.dropdown.Option("Newest"),
                ft.dropdown.Option("Oldest"),
                ft.dropdown.Option("Time"),
                ft.dropdown.Option("Expl"),
                ft.dropdown.Option("Height"),
            ],
            on_change=self.on_sort_change,
            content_padding=5,
            height=35
        )

        self.hide_fails_button = ft.IconButton(
            icon=ft.icons.FILTER_ALT_OFF,
            icon_color="white",
            selected_icon=ft.icons.FILTER_ALT,
            selected_icon_color="red",
            selected=self.hide_failures,
            tooltip="Hide Fails",
            on_click=self.on_hide_fail_click
        )
        self.hide_wl_button = ft.IconButton(
            icon=ft.icons.PUBLIC_OFF,
            icon_color="white",
            selected_icon=ft.icons.PUBLIC_OFF,
            selected_icon_color="blue",
            selected=self.hide_world_loads,
            tooltip="Hide World Loads",
            on_click=self.on_hide_wl_click
        )

        controls_row = ft.Row([
            ft.Row([self.chart_toggle, self.trend_button, self.group_input], alignment=ft.MainAxisAlignment.START, spacing=15),
            ft.Container(expand=True),
            ft.Row([
                ft.Text("Sort:", size=12, color="grey"),
                self.sort_dropdown,
                ft.Container(width=10),
                self.hide_wl_button,
                self.hide_fails_button
            ], vertical_alignment=ft.CrossAxisAlignment.CENTER)
        ], alignment=ft.MainAxisAlignment.SPACE_BETWEEN)

        self.chart_container = ft.Container(height=220, padding=10, bgcolor=ft.colors.BLACK54, border_radius=8)
        self.stats_container = ft.Row(alignment=ft.MainAxisAlignment.SPACE_EVENLY, spacing=30)

        self.runs_table = ft.DataTable(
            columns=[
                ft.DataColumn(ft.Text("Result")),
                ft.DataColumn(ft.Text("Expl"), numeric=True),
                ft.DataColumn(ft.Text("Time"), numeric=True),
                ft.DataColumn(ft.Text("Height"), numeric=True),
                ft.DataColumn(ft.Text("Tower")),
                ft.DataColumn(ft.Text("Type")),
            ],
            rows=[],
            column_spacing=25, 
            heading_row_height=30,
            data_row_min_height=35,
        )

        self.main_container.content = ft.Column([
            nav_row,
            ft.Divider(height=15, color="transparent"),
            controls_row,
            self.chart_container,
            ft.Divider(height=15, color="transparent"),
            self.stats_container,
            ft.Divider(),
            ft.Container(content=ft.Column([self.runs_table], scroll=ft.ScrollMode.ADAPTIVE), expand=True)
        ], expand=True)
        
        self._refresh_detail_content()
        self.update()

    # --- EVENT HANDLERS (Same as before) ---
    def on_chart_mode_change(self, e):
        self.chart_mode = list(e.control.selected)[0]
        self._refresh_detail_content()
        self.update()

    def on_trend_click(self, e):
        self.show_trend = not self.show_trend
        self.trend_button.selected = self.show_trend
        self.trend_button.update()
        self._refresh_detail_content()
        self.update()
    
    def on_hide_fail_click(self, e):
        self.hide_failures = not self.hide_failures
        self.hide_fails_button.selected = self.hide_failures
        self.hide_fails_button.update()
        self._refresh_detail_content()
        self.update()
    
    def on_hide_wl_click(self, e):
        self.hide_world_loads = not self.hide_world_loads
        self.hide_wl_button.selected = self.hide_world_loads
        self.hide_wl_button.update()
        self._refresh_detail_content()
        self.update()

    def on_sort_change(self, e):
        self.sort_option = e.control.value
        self._refresh_detail_content()
        self.update()

    def on_group_submit(self, e):
        try:
            val = int(e.control.value)
            if val < 1: val = 1
            self.group_size = val
        except:
            self.group_size = 1
            e.control.value = "1"
            e.control.update()
        self._refresh_detail_content()
        self.update()

    # --- REFRESH LOGIC (Same as before) ---
    def _refresh_detail_content(self):
        active_runs = list(self.detail_runs)
        if self.hide_world_loads:
            active_runs = [r for r in active_runs if r[10] != "World Load"]

        total_runs = len(active_runs)
        successes = [r for r in active_runs if r[9]]
        deaths = [r for r in active_runs if r[10] == "Death"]
        death_count = len(deaths)
        
        success_rate = (len(successes) / total_runs * 100) if total_runs > 0 else 0.0
        death_rate = (death_count / total_runs * 100) if total_runs > 0 else 0.0
        
        heights = [r[7] for r in active_runs if r[7] > 0]
        avg_height = sum(heights) / len(heights) if heights else 0
        
        # Session Time Calc (Smart)
        time_sorted_runs = sorted(active_runs, key=lambda x: x[1])
        session_time_seconds = 0
        if time_sorted_runs:
            current_chunk_start = datetime.strptime(time_sorted_runs[0][1], "%Y-%m-%d %H:%M:%S")
            current_chunk_end = current_chunk_start + timedelta(seconds=time_sorted_runs[0][2])
            
            for i in range(1, len(time_sorted_runs)):
                run_start = datetime.strptime(time_sorted_runs[i][1], "%Y-%m-%d %H:%M:%S")
                run_duration = time_sorted_runs[i][2]
                run_end = run_start + timedelta(seconds=run_duration)
                gap = (run_start - current_chunk_end).total_seconds()
                
                if gap > 1800:
                    chunk_duration = (current_chunk_end - current_chunk_start).total_seconds()
                    session_time_seconds += chunk_duration
                    current_chunk_start = run_start
                    current_chunk_end = run_end
                else:
                    if run_end > current_chunk_end:
                        current_chunk_end = run_end
            
            chunk_duration = (current_chunk_end - current_chunk_start).total_seconds()
            session_time_seconds += chunk_duration

        m, s = divmod(session_time_seconds, 60)
        h, m = divmod(m, 60)
        dur_str = f"{int(h)}:{int(m):02d}:{int(s):02d}"

        self.stats_container.controls = [
            self._stat_card("Total Runs", str(total_runs), ft.colors.WHITE),
            self._stat_card("Success Rate", f"{success_rate:.1f}%", ft.colors.GREEN_400 if success_rate > 50 else ft.colors.ORANGE_400),
            self._stat_card("Death Rate", f"{death_rate:.1f}%", ft.colors.RED_400),
            self._stat_card("Avg Height", f"{int(avg_height)}", ft.colors.CYAN_400),
            self._stat_card("Session Time", dur_str, ft.colors.GREY_400),
        ]

        # Chart
        chart_data_source = sorted(successes, key=lambda x: x[1])
        y_values = []
        if self.chart_mode == "expl":
            y_values = [r[4] for r in chart_data_source if r[4] > 0]
            chart_color = ft.colors.CYAN_400
            y_title = "Explosives"
        else:
            y_values = [r[2] for r in chart_data_source]
            chart_color = ft.colors.PURPLE_400
            y_title = "Time (s)"

        points = []
        final_coords = []
        
        if self.group_size > 1:
            for i in range(0, len(y_values), self.group_size):
                chunk = y_values[i : i + self.group_size]
                if chunk:
                    avg = sum(chunk) / len(chunk)
                    points.append(ft.LineChartDataPoint(x=i, y=avg))
                    final_coords.append((i, avg))
        else:
            for i, val in enumerate(y_values):
                points.append(ft.LineChartDataPoint(x=i, y=val))
                final_coords.append((i, val))

        data_series = [
            ft.LineChartData(
                data_points=points,
                stroke_width=2,
                color=chart_color,
                curved=True,
                stroke_cap_round=True,
                below_line_bgcolor=ft.colors.with_opacity(0.1, chart_color),
            )
        ]

        if self.show_trend and len(final_coords) > 1:
            n = len(final_coords)
            sum_x = sum(x for x, y in final_coords)
            sum_y = sum(y for x, y in final_coords)
            sum_xy = sum(x*y for x, y in final_coords)
            sum_xx = sum(x*x for x, y in final_coords)
            denom = (n * sum_xx - sum_x * sum_x)
            if denom != 0:
                m = (n * sum_xy - sum_x * sum_y) / denom
                b = (sum_y - m * sum_x) / n
                start_x, end_x = final_coords[0][0], final_coords[-1][0]
                data_series.append(ft.LineChartData(
                    data_points=[ft.LineChartDataPoint(x=start_x, y=m*start_x+b), ft.LineChartDataPoint(x=end_x, y=m*end_x+b)],
                    stroke_width=1, color=ft.colors.WHITE54, dash_pattern=[5, 5]
                ))

        chart = ft.LineChart(
            data_series=data_series,
            border=ft.border.all(1, ft.colors.GREY_800),
            left_axis=ft.ChartAxis(labels_size=30, title=ft.Text(y_title, size=10)),
            bottom_axis=ft.ChartAxis(labels_size=0),
            tooltip_bgcolor=ft.colors.GREY_800,
            expand=True
        )
        self.chart_container.content = chart

        # Table
        table_runs = list(active_runs)
        if self.hide_failures:
            table_runs = [r for r in table_runs if r[9]]

        if self.sort_option == "Newest":
            table_runs.sort(key=lambda x: (x[1], x[0]), reverse=True)
        elif self.sort_option == "Oldest":
            table_runs.sort(key=lambda x: (x[1], x[0]), reverse=False)
        elif self.sort_option == "Time":
            table_runs.sort(key=lambda x: (not x[9], x[2])) 
        elif self.sort_option == "Expl":
            table_runs.sort(key=lambda x: (not x[9], x[4]))
        elif self.sort_option == "Height":
            table_runs.sort(key=lambda x: x[7], reverse=True)
        
        new_rows = []
        for run in table_runs:
            is_success = bool(run[9])
            time_val = run[2]
            expl_str = run[3]
            tower = run[5]
            r_type = run[6]
            height = run[7]
            fail_reason = run[10]

            if is_success:
                res_content = ft.Text("CLEARED", color=ft.colors.GREEN_400, weight="bold", size=12)
                row_bg = ft.colors.with_opacity(0.05, ft.colors.GREEN_400)
            else:
                res_content = ft.Text(f"{fail_reason}", color=ft.colors.RED_400, size=12)
                row_bg = ft.colors.TRANSPARENT

            new_rows.append(
                ft.DataRow(
                    color=row_bg,
                    cells=[
                        ft.DataCell(res_content),
                        ft.DataCell(ft.Text(expl_str if expl_str != "?" else "-")),
                        ft.DataCell(ft.Text(f"{time_val:.2f}s")),
                        ft.DataCell(ft.Text(str(height))),
                        ft.DataCell(ft.Text(tower if tower != "Unknown" else "-")),
                        ft.DataCell(ft.Text(r_type if r_type != "Unknown" else "-")),
                    ],
                )
            )
        self.runs_table.rows = new_rows

    def _stat_card(self, label, value, color):
        return ft.Column([
            ft.Text(label, size=11, color="grey"),
            ft.Text(value, size=20, weight="bold", color=color)
        ], horizontal_alignment="center")

    def show_list(self):
        self._build_list_view()
        self.update()
--- END OF FILE: components\session_analytics.py ---

--- START OF FILE: components\tower_analytics.py ---
import flet as ft
import database
import config

class TowerAnalytics(ft.UserControl):
    def __init__(self):
        super().__init__()
        self.view_mode = "grid"
        self.current_tower = None
        self.all_runs = []
        self.active_types = set()
        
        # State
        self.detail_sort_option = "Newest"
        self.grid_sort_option = "Most Runs" 
        self.chart_mode = "expl" 
        self.hide_failures = False
        self.show_trend = False
        self.group_size = 1 # Default 1 means no grouping
        self.tower_names = [] # Sorted names for navigation
        
        self.main_container = ft.Container(expand=True)

    def did_mount(self):
        # Load persisted state
        cfg = config.load_config(self.page)
        self.chart_mode = cfg.get("chart_mode", "expl")
        self.update()

    def build(self):
        self._build_grid()
        return self.main_container

    def show_grid(self):
        self._build_grid()
        self.update()

    def _build_grid(self):
        self.view_mode = "grid"
        self.current_tower = None
        
        basic_stats = database.get_tower_stats()
        tower_data = {}

        for t_name, _, _ in basic_stats:
            runs = database.get_runs_by_tower(t_name)
            total_count = len(runs)
            success_runs = [r for r in runs if r[9]] # is_success=1
            success_count = len(success_runs)
            
            if success_count == 0:
                continue

            # Calculate Stats
            # Calculate Stats
            avg_expl = sum(r[4] for r in success_runs) / success_count
            
            valid_time_runs = [r for r in success_runs if r[2] > 0]
            if valid_time_runs:
                avg_time = sum(r[2] for r in valid_time_runs) / len(valid_time_runs)
                best_time = min(r[2] for r in valid_time_runs)
            else:
                avg_time = 0
                best_time = 0
            
            best_expl = min(r[4] for r in success_runs)
            
            tower_data[t_name] = {
                'total': success_count, # Re-purposed as successful count
                'avg_expl': avg_expl,
                'avg_time': avg_time,
                'best_expl': best_expl,
                'best_time': best_time
            }

        stats_list = []
        for t_name, data in tower_data.items():
            stats_list.append((t_name, data))

        # Sort Logic
        if self.grid_sort_option == "Most Runs":
            stats_list.sort(key=lambda x: x[1]['total'], reverse=True)
        elif self.grid_sort_option == "Best Time":
            stats_list.sort(key=lambda x: x[1]['best_time'], reverse=False)
        elif self.grid_sort_option == "Best Avg Expl":
            stats_list.sort(key=lambda x: x[1]['avg_expl'], reverse=False)
        elif self.grid_sort_option == "Alphabetical":
            stats_list.sort(key=lambda x: x[0], reverse=False)
            
        self.tower_names = [x[0] for x in stats_list]

        cards = []
        for t_name, data in stats_list:

            
            card_content = ft.Column([
                ft.Text(t_name, size=20, weight="bold", no_wrap=True, text_align="center"),
                ft.Divider(height=5, color="transparent"),
                
                # Stats Grid
                ft.Row([
                    # Expl Column (Left)
                    ft.Column([
                        ft.Text("Best Expl", size=12, color="grey"),
                        ft.Text(f"{data.get('best_expl', '-')}", size=18, weight="bold", color=ft.colors.CYAN_400),
                        ft.Container(height=5),
                        ft.Text("Avg Expl", size=12, color="grey"),
                        ft.Text(f"{data['avg_expl']:.1f}", size=18, weight="bold"),
                    ], spacing=2, horizontal_alignment=ft.CrossAxisAlignment.CENTER),
                    
                    ft.VerticalDivider(width=10, color="grey"),

                     # Time Column (Right)
                    ft.Column([
                        ft.Text("Best Time", size=12, color="grey"),
                        ft.Text(f"{data.get('best_time', 0):.1f}s", size=18, weight="bold", color=ft.colors.AMBER_400),
                        ft.Container(height=5),
                        ft.Text("Avg Time", size=12, color="grey"),
                        ft.Text(f"{data.get('avg_time', 0):.1f}s", size=18, weight="bold"),
                    ], spacing=2, horizontal_alignment=ft.CrossAxisAlignment.CENTER),
                ], alignment=ft.MainAxisAlignment.SPACE_EVENLY, expand=True),
                
                ft.Container(expand=True),
                ft.Text(f"{data['total']} Successful Runs", size=13, weight="bold", color=ft.colors.WHITE70)
            ], alignment=ft.MainAxisAlignment.SPACE_EVENLY, horizontal_alignment=ft.CrossAxisAlignment.CENTER, spacing=2)

            container = ft.Container(
                content=card_content,
                bgcolor=ft.colors.GREY_900,
                border_radius=8,
                padding=10,
                ink=True,
                on_click=lambda e, n=t_name: self.show_detail(n)
            )
            cards.append(container)

        grid = ft.GridView(
            controls=cards,
            runs_count=5, 
            child_aspect_ratio=1.0, 
            spacing=10,
            run_spacing=10,
            expand=True
        )
        
        sort_dropdown = ft.Dropdown(
            width=140,
            text_size=12,
            value=self.grid_sort_option,
            options=[
                ft.dropdown.Option("Most Runs"),
                ft.dropdown.Option("Best Time"),
                ft.dropdown.Option("Best Avg Expl"),
                ft.dropdown.Option("Alphabetical"),
            ],
            on_change=self.on_grid_sort_change,
            content_padding=5,
            height=30
        )

        header_row = ft.Row([
            ft.Text("Tower Analytics", size=20, weight="bold"),
            ft.Container(expand=True),
            ft.Text("Sort:", size=12, color="grey"),
            sort_dropdown
        ], alignment=ft.MainAxisAlignment.SPACE_BETWEEN)
        
        self.main_container.content = ft.Column([
            header_row,
            ft.Divider(),
            grid
        ], expand=True)

    def on_grid_sort_change(self, e):
        self.grid_sort_option = e.control.value
        self.show_grid()

    def show_detail(self, tower_name, initial_filter_type=None):
        self.view_mode = "detail"
        self.current_tower = tower_name
        self.all_runs = database.get_runs_by_tower(tower_name)
        
        unique_types = sorted(list(set(r[6] for r in self.all_runs if r[6] and r[6] != "Unknown")))
        if initial_filter_type and initial_filter_type in unique_types:
            self.active_types = {initial_filter_type}
        else:
            self.active_types = set(unique_types)
        
        # --- UI CONTROLS ---
        tower_index = self.tower_names.index(tower_name) if tower_name in self.tower_names else -1
        
        nav_header = ft.Row([
            ft.IconButton(ft.icons.ARROW_BACK, tooltip="Back to Comparison", on_click=lambda e: self.show_grid()),
            ft.Container(width=10),
            ft.IconButton(
                ft.icons.CHEVRON_LEFT, 
                tooltip="Next Tower (Up)",
                disabled=(tower_index <= 0), 
                on_click=lambda e: self.show_detail(self.tower_names[tower_index - 1])
            ),
            ft.IconButton(
                ft.icons.CHEVRON_RIGHT, 
                tooltip="Prev Tower (Down)",
                disabled=(tower_index == -1 or tower_index >= len(self.tower_names) - 1), 
                on_click=lambda e: self.show_detail(self.tower_names[tower_index + 1])
            ),
            ft.Container(width=10),
            ft.Text(f"{tower_name}", size=24, weight="bold"),
        ], alignment=ft.MainAxisAlignment.START)

        self.filter_row = ft.Row(wrap=True, expand=True)
        self._build_filter_controls(unique_types)

        self.chart_toggle = ft.SegmentedButton(
            selected={self.chart_mode},
            show_selected_icon=False,
            segments=[
                ft.Segment(value="expl", label=ft.Text("Explosives")),
                ft.Segment(value="time", label=ft.Text("Time")),
            ],
            on_change=self.on_chart_mode_change
        )
        
        # NEW CONTROLS
        self.trend_button = ft.IconButton(
            icon=ft.icons.TIMELINE,
            icon_color="white",
            selected_icon=ft.icons.TIMELINE,
            selected_icon_color="cyan",
            selected=self.show_trend,
            tooltip="Toggle Trend Line",
            on_click=self.on_trend_click
        )

        self.group_input = ft.TextField(
            label="Group", 
            value=str(self.group_size), 
            width=60, 
            text_size=12,
            content_padding=5,
            keyboard_type=ft.KeyboardType.NUMBER,
            on_submit=self.on_group_submit,
            on_blur=self.on_group_submit
        )

        self.detail_sort_dropdown = ft.Dropdown(
            width=100,
            text_size=12,
            value=self.detail_sort_option,
            options=[
                ft.dropdown.Option("Newest"),
                ft.dropdown.Option("Oldest"),
                ft.dropdown.Option("Best Expl"),
                ft.dropdown.Option("Best Time"),
            ],
            on_change=self.on_detail_sort_change,
            content_padding=5
        )

        # Organization
        controls_row_1 = ft.Row([
            ft.Column([ft.Text("Filter Type:", size=12, color="grey"), self.filter_row], expand=True),
        ])
        
        controls_row_2 = ft.Row([
            self.chart_toggle,
            ft.Container(width=10),
            self.trend_button,
            self.group_input,
            ft.Container(expand=True),
            self.detail_sort_dropdown
        ], alignment=ft.MainAxisAlignment.START)

        self.chart_container = ft.Container(height=300, padding=10, bgcolor=ft.colors.BLACK54, border_radius=8)
        self.stats_container = ft.Row(alignment=ft.MainAxisAlignment.SPACE_AROUND)
        self.list_container = ft.Column(scroll=ft.ScrollMode.ADAPTIVE, expand=True)
        
        list_header = ft.Container(
            content=ft.Row([
                ft.Text("Expl", width=50, weight="bold", color="grey"),
                ft.Text("Time", width=100, weight="bold", color="grey"),
                ft.Text("Bed", width=60, weight="bold", color="grey"),
                ft.Text("Y", width=30, weight="bold", color="grey"),
                ft.Text("Type", expand=True, weight="bold", color="grey"),
                ft.Text("Date", width=120, weight="bold", color="grey"),
            ]),
            padding=ft.padding.only(left=5, bottom=5)
        )

        self.main_container.content = ft.Column([
            nav_header,
            controls_row_1,
            ft.Container(height=5),
            controls_row_2,
            self.chart_container,
            ft.Divider(height=10, color="transparent"),
            self.stats_container,
            ft.Divider(),
            ft.Text("Run History", weight="bold"),
            list_header,
            self.list_container
        ], expand=True)
        
        self._refresh_detail_content()
        self.update()

    # --- EVENT HANDLERS ---
    def _build_filter_controls(self, all_types):
        controls = []
        for t_type in all_types:
            is_active = t_type in self.active_types
            bg_color = ft.colors.BLUE_700 if is_active else ft.colors.TRANSPARENT
            border_color = ft.colors.BLUE_700 if is_active else ft.colors.GREY_700
            
            btn = ft.Container(
                content=ft.Text(t_type, size=12, color="white" if is_active else "grey"),
                padding=8,
                border_radius=15,
                bgcolor=bg_color,
                border=ft.border.all(1, border_color),
                ink=True,
                on_click=lambda e, t=t_type: self.toggle_filter(t)
            )
            controls.append(btn)
        self.filter_row.controls = controls

    def toggle_filter(self, t_type):
        if t_type in self.active_types:
            self.active_types.remove(t_type)
        else:
            self.active_types.add(t_type)
        current_buttons = self.filter_row.controls
        all_types_in_ui = [btn.content.value for btn in current_buttons]
        self._build_filter_controls(all_types_in_ui)
        self.filter_row.update()
        self._refresh_detail_content()
        self.update()

    def on_chart_mode_change(self, e):
        self.chart_mode = list(e.control.selected)[0]
        # Persist
        config.save_config(self.page, {"chart_mode": self.chart_mode})
        
        self._refresh_detail_content()
        self.update()

    def on_detail_sort_change(self, e):
        self.detail_sort_option = self.detail_sort_dropdown.value
        self._refresh_detail_content()
        self.update()

    def on_trend_click(self, e):
        self.show_trend = not self.show_trend
        self.trend_button.selected = self.show_trend
        
        # Persist
        config.save_config(self.page, {"show_trend": self.show_trend})
        
        self.trend_button.update()
        self._refresh_detail_content()
        self.update()

    def on_group_submit(self, e):
        try:
            val = int(e.control.value)
            if val < 1: val = 1
            self.group_size = val
        except:
            self.group_size = 1
            e.control.value = "1"
            e.control.update()
        self._refresh_detail_content()
        self.update()

    # --- REFRESH LOGIC ---
    def _refresh_detail_content(self):
        filtered_runs = [r for r in self.all_runs if r[6] in self.active_types]
        
        # Stats Calculation
        total = len(filtered_runs)
        successes = [r for r in filtered_runs if r[9]]
        success_count = len(successes)
        
        avg_expl_val = 0
        avg_time_val = 0
        best_expl_val = 0
        best_time_val = 0
        
        if success_count > 0:
            avg_expl_val = sum(r[4] for r in successes) / success_count
            best_expl_val = min(r[4] for r in successes)
            
            valid_time_runs = [r for r in successes if r[2] > 0]
            if valid_time_runs:
                avg_time_val = sum(r[2] for r in valid_time_runs) / len(valid_time_runs)
                best_time_val = min(r[2] for r in valid_time_runs)
            
        self.stats_container.controls = [
             ft.Column([
                ft.Text("Successful Runs", color="grey"), 
                ft.Text(f"{success_count}", size=20, weight="bold")
            ], horizontal_alignment=ft.CrossAxisAlignment.CENTER),
            
            ft.VerticalDivider(width=20, color="grey"),
            
            ft.Row([
                ft.Column([
                    ft.Text("Best Expl", color="grey", size=12),
                    ft.Text(f"{best_expl_val}", size=16, weight="bold", color=ft.colors.CYAN_400),
                ], horizontal_alignment=ft.CrossAxisAlignment.CENTER),
                ft.Column([
                    ft.Text("Avg Expl", color="grey", size=12),
                    ft.Text(f"{avg_expl_val:.2f}", size=16, weight="bold"),
                ], horizontal_alignment=ft.CrossAxisAlignment.CENTER),
            ], spacing=20),
            
            ft.VerticalDivider(width=20, color="grey"),

            ft.Row([
                 ft.Column([
                    ft.Text("Best Time", color="grey", size=12),
                    ft.Text(f"{best_time_val:.2f}s", size=16, weight="bold", color=ft.colors.AMBER_400),
                ], horizontal_alignment=ft.CrossAxisAlignment.CENTER),
                ft.Column([
                    ft.Text("Avg Time", color="grey", size=12),
                    ft.Text(f"{avg_time_val:.2f}s", size=16, weight="bold"),
                ], horizontal_alignment=ft.CrossAxisAlignment.CENTER),
            ], spacing=20),
        ]

        # --- CHART LOGIC ---
        # Sort chronologically for chart
        chart_data_source = sorted(successes, key=lambda x: x[1])
        
        # Extract Y values (Explosives or Time)
        # FILTER: Ignore 0 explosives to avoid the bug/noise
        y_values = []
        if self.chart_mode == "expl":
            y_values = [r[4] for r in chart_data_source if r[4] > 0]
            y_title = "Explosives"
            chart_color = ft.colors.CYAN_400
        else:
            y_values = [r[2] for r in chart_data_source]
            y_title = "Time (s)"
            chart_color = ft.colors.PURPLE_400

        # Apply Grouping
        points = []
        final_y_values = [] # For Trend Line calculation
        
        if self.group_size > 1:
            for i in range(0, len(y_values), self.group_size):
                chunk = y_values[i : i + self.group_size]
                if chunk:
                    avg = sum(chunk) / len(chunk)
                    points.append(ft.LineChartDataPoint(x=i, y=avg))
                    final_y_values.append((i, avg))
        else:
            for i, val in enumerate(y_values):
                points.append(ft.LineChartDataPoint(x=i, y=val))
                final_y_values.append((i, val))

        data_series = [
            ft.LineChartData(
                data_points=points,
                stroke_width=2,
                color=chart_color,
                curved=True,
                stroke_cap_round=True,
                below_line_bgcolor=ft.colors.with_opacity(0.1, chart_color),
            )
        ]

        # Calculate Trend Line (Linear Regression)
        if self.show_trend and len(final_y_values) > 1:
            # simple linear regression: y = mx + b
            # x values are the index (or grouped index)
            n = len(final_y_values)
            sum_x = sum(x for x, y in final_y_values)
            sum_y = sum(y for x, y in final_y_values)
            sum_xy = sum(x*y for x, y in final_y_values)
            sum_xx = sum(x*x for x, y in final_y_values)
            
            denominator = (n * sum_xx - sum_x * sum_x)
            if denominator != 0:
                m = (n * sum_xy - sum_x * sum_y) / denominator
                b = (sum_y - m * sum_x) / n
                
                # Create line from first X to last X
                start_x = final_y_values[0][0]
                end_x = final_y_values[-1][0]
                
                trend_points = [
                    ft.LineChartDataPoint(x=start_x, y=m*start_x + b),
                    ft.LineChartDataPoint(x=end_x, y=m*end_x + b)
                ]
                
                data_series.append(
                    ft.LineChartData(
                        data_points=trend_points,
                        stroke_width=2,
                        color=ft.colors.WHITE54,
                        dash_pattern=[5, 5],
                        curved=False
                    )
                )

        chart = ft.LineChart(
            data_series=data_series,
            border=ft.border.all(1, ft.colors.GREY_800),
            left_axis=ft.ChartAxis(labels_size=30, title=ft.Text(y_title, size=10)),
            bottom_axis=ft.ChartAxis(title=ft.Text(f"Runs (Grouped by {self.group_size})" if self.group_size > 1 else "Runs", size=10), labels_size=0),
            tooltip_bgcolor=ft.colors.GREY_800,
            expand=True
        )
        self.chart_container.content = chart

        # --- LIST LOGIC ---
        # Sort for List View
        sorted_runs = list(filtered_runs)
        if self.detail_sort_option == "Newest":
            sorted_runs.sort(key=lambda x: (x[1], x[0]), reverse=True)
        elif self.detail_sort_option == "Oldest":
            sorted_runs.sort(key=lambda x: (x[1], x[0]), reverse=False)
        elif self.detail_sort_option == "Best Expl":
            sorted_runs.sort(key=lambda x: x[4] if x[9] else 999, reverse=False)
        elif self.detail_sort_option == "Best Time":
            sorted_runs.sort(key=lambda x: x[2] if x[2] > 0 else 999, reverse=False)

        list_rows = []
        for run in sorted_runs:
            time_val = run[2]
            expl_str = run[3]
            r_type = run[6]
            bed = run[8]
            is_success = bool(run[9])
            fail_reason = run[10]
            date_str = run[1]
            
            height = run[7]
            
            # Hide Failure Logic
            if not is_success and self.hide_failures:
                continue

            if is_success:
                row_content = [
                    ft.Text(f"{expl_str}", width=50, weight="bold", color=ft.colors.CYAN_200, size=16),
                    ft.Text(f"{time_val:.2f}s", width=100, weight="bold"),
                    ft.Text(f"{bed:.2f}s" if bed else "-", width=60, color=ft.colors.ORANGE_300),
                    ft.Text(f"{height}" if height > 0 else "-", width=30, color="grey"),
                    ft.Text(f"{r_type}", expand=True, size=14),
                    ft.Text(date_str, width=120, size=12, color="grey")
                ]
                bg_col = ft.colors.TRANSPARENT
            else:
                row_content = [
                    ft.Text("-", width=50, weight="bold", color="grey"),
                    ft.Text(f"{time_val:.1f}s ({fail_reason})", width=100, color=ft.colors.RED_400, weight="bold"),
                    ft.Text("-", width=60, color="grey"),
                    ft.Text("-", width=30, color="grey"),
                    ft.Text(f"{r_type}", expand=True, size=14, italic=True, color="grey"),
                    ft.Text(date_str, width=120, size=12, color="grey")
                ]
                bg_col = ft.colors.with_opacity(0.05, ft.colors.RED)

            row = ft.Container(
                content=ft.Row(row_content, alignment=ft.MainAxisAlignment.START),
                padding=10,
                bgcolor=bg_col,
                border=ft.border.only(bottom=ft.border.BorderSide(1, "#333333"))
            )
            list_rows.append(row)
        
        self.list_container.controls = list_rows
--- END OF FILE: components\tower_analytics.py ---

--- START OF FILE: config.py ---
import json

# In-memory DB path (no filesystem in browser)
DB_PATH = ":memory:"

# Common log folder paths to display as hints in the UI
# These help users navigate to their logs folder in the file picker
COMMON_LOG_PATHS = [
    r"%APPDATA%\PrismLauncher\instances\MCSRRanked-1.16.1\logs",
    r"%APPDATA%\PrismLauncher\instances\Ranked\logs",
    r"%APPDATA%\MultiMC\instances\MCSRRanked-1.16.1\logs",
    r"%USERPROFILE%\Downloads\mmc-develop-win32\MultiMC\instances\MCSRRanked-Windows-1.16.1-All.minecraft\logs",
]

DEFAULT_CONFIG = {
    "left_panel_width": 630,
    "navigation_mode": "default",
    "show_splits_only": False,
    "chart_mode": "expl",
    "hide_fails": False,
    "show_trend": False,
}

def load_config(page):
    """Load config from browser's localStorage via page.client_storage."""
    try:
        raw = page.client_storage.get("mcsr_config")
        if raw:
            return {**DEFAULT_CONFIG, **json.loads(raw)}
    except:
        pass
    return dict(DEFAULT_CONFIG)

def save_config(page, new_config):
    """Save config to browser's localStorage via page.client_storage."""
    current = load_config(page)
    current.update(new_config)
    page.client_storage.set("mcsr_config", json.dumps(current))
--- END OF FILE: config.py ---

--- START OF FILE: database.py ---
import sqlite3
import json

# Single persistent in-memory connection (no threading in browser)
_conn = None

def _get_conn():
    """Get or create the in-memory SQLite connection."""
    global _conn
    if _conn is None:
        _conn = sqlite3.connect(":memory:", check_same_thread=False)
        _init_schema(_conn)
    return _conn

def _init_schema(conn):
    """Create the attempts table if it doesn't exist."""
    with conn:
        conn.execute('''CREATE TABLE IF NOT EXISTS attempts (
            id INTEGER PRIMARY KEY,
            timestamp TEXT,
            time_sec REAL,
            explosives TEXT,
            total_explosives INTEGER,
            tower TEXT,
            type TEXT,
            height INTEGER,
            bed_time REAL,
            is_success INTEGER, 
            fail_reason TEXT,
            session_id TEXT,
            split_tag TEXT,
            fingerprint TEXT UNIQUE
        )''')

def init_db():
    """Initialize the database (creates table in memory)."""
    _get_conn()

# ===========================
# PERSISTENCE (Browser Storage)
# ===========================

def save_to_storage(page):
    """Serialize all rows to JSON and save to browser storage."""
    try:
        conn = _get_conn()
        rows = conn.execute("SELECT * FROM attempts").fetchall()
        data = json.dumps(rows)
        page.client_storage.set("mcsr_db", data)
    except Exception as e:
        print(f"Save to storage error: {e}")

def load_from_storage(page):
    """Load data from browser storage into in-memory SQLite."""
    try:
        raw = page.client_storage.get("mcsr_db")
        if raw:
            rows = json.loads(raw)
            conn = _get_conn()
            with conn:
                for row in rows:
                    try:
                        conn.execute(
                            "INSERT OR IGNORE INTO attempts VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?)",
                            tuple(row)
                        )
                    except Exception:
                        pass
            print(f"Loaded {len(rows)} rows from browser storage.")
    except Exception as e:
        print(f"Load from storage error: {e}")

def get_row_count():
    """Get the total number of rows in the database."""
    conn = _get_conn()
    result = conn.execute("SELECT COUNT(*) FROM attempts").fetchone()
    return result[0] if result else 0

# ===========================
# EXPORT / IMPORT (User-facing backup)
# ===========================

def export_json():
    """Return all data as a JSON string for user download."""
    conn = _get_conn()
    # Explicitly select columns to ensure stable order
    cols = ["id", "timestamp", "time_sec", "explosives", "total_explosives", "tower", "type", "height", "bed_time", "is_success", "fail_reason", "session_id", "split_tag", "fingerprint"]
    query = f"SELECT {', '.join(cols)} FROM attempts ORDER BY timestamp ASC, id ASC"
    rows = conn.execute(query).fetchall()
    return json.dumps([dict(zip(cols, row)) for row in rows], indent=2)

def import_json(data_str):
    """Import data from a JSON backup string. Maps compatible keys."""
    try:
        records = json.loads(data_str)
        conn = _get_conn()
        count = 0
        with conn:
            for rec in records:
                # Map column names to save_run expected keys
                mapped_data = {
                    'timestamp': rec.get('timestamp'),
                    'time': rec.get('time_sec') if 'time_sec' in rec else rec.get('time', 0),
                    'expl': rec.get('explosives') if 'explosives' in rec else rec.get('expl', '?'),
                    'tower': rec.get('tower', 'Unknown'),
                    'type': rec.get('type') if 'type' in rec else rec.get('run_type', 'Unknown'),
                    'height': rec.get('height', 0),
                    'bed_time': rec.get('bed_time'),
                    'is_success': bool(rec.get('is_success', False)),
                    'fail_reason': rec.get('fail_reason'),
                    'session_id': rec.get('session_id'),
                    'split_tag': rec.get('split_tag')
                }
                if _save_run_internal(conn, mapped_data):
                    count += 1
        return count
    except Exception as e:
        print(f"Import JSON error: {e}")
        return 0

# ===========================
# CORE DATA OPERATIONS
# ===========================

def save_run(data):
    """Saves a run with transaction handling."""
    conn = _get_conn()
    with conn:
        return _save_run_internal(conn, data)

def _save_run_internal(conn, data):
    """Internal save helper that assumes an active transaction."""
    # 1. Calculate Total Explosives
    expl_str = data.get('expl', '?')
    total_expl = 0
    if expl_str and expl_str != "?":
        try:
            if '+' in expl_str:
                parts = expl_str.split('+')
                total_expl = int(parts[0]) + int(parts[1])
            else:
                total_expl = int(expl_str)
        except:
            total_expl = 0
            
    # 2. Construct Fingerprint
    fingerprint = f"{data.get('session_id', 'live')}_{data['timestamp']}_{data.get('time', 0)}"

    try:
        # Prevent duplicates
        cursor = conn.cursor()
        cursor.execute("SELECT 1 FROM attempts WHERE fingerprint = ?", (fingerprint,))
        if cursor.fetchone():
            return False 

        cursor.execute('''
            INSERT INTO attempts (
                timestamp, time_sec, explosives, total_explosives,
                tower, type, height, bed_time, 
                is_success, fail_reason, session_id, split_tag, fingerprint
            )
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            data['timestamp'], 
            data.get('time', 0), 
            expl_str,
            total_expl,
            data.get('tower', 'Unknown'), 
            data.get('type', 'Unknown'), 
            data.get('height', 0), 
            data.get('bed_time'),
            1 if data.get('is_success', False) else 0,
            data.get('fail_reason', data.get('raw_fail_reason', None)),
            data.get('session_id'),
            data.get('split_tag'),
            fingerprint
        ))
        
        return True
    except sqlite3.IntegrityError:
        return False
    except Exception as e:
        print(f"DB Error: {e}")
        return False

# ===========================
# QUERY FUNCTIONS (unchanged API)
# ===========================

def get_recent_runs(limit=100):
    conn = _get_conn()
    # Order by timestamp first for chronological accuracy
    runs = conn.execute(f"SELECT * FROM attempts ORDER BY timestamp DESC, id DESC LIMIT {limit}").fetchall()
    return runs

def get_tower_stats():
    conn = _get_conn()
    rows = conn.execute('''
        SELECT tower, MIN(time_sec), COUNT(*) 
        FROM attempts 
        WHERE is_success = 1 AND tower IS NOT NULL AND tower != 'Unknown'
        GROUP BY tower 
        ORDER BY COUNT(*) DESC
    ''').fetchall()
    return rows

def get_runs_by_tower(tower_name):
    conn = _get_conn()
    rows = conn.execute("SELECT * FROM attempts WHERE tower = ? ORDER BY timestamp ASC", (tower_name,)).fetchall()
    return rows

def get_pbs_map():
    conn = _get_conn()
    rows = conn.execute('''
        SELECT tower, type, MIN(total_explosives)
        FROM attempts
        WHERE is_success = 1 AND tower != 'Unknown'
        GROUP BY tower, type
    ''').fetchall()
    
    pb_map = {}
    for r in rows:
        pb_map[(r[0], r[1])] = r[2]
    return pb_map

# --- SESSION FUNCTIONS ---

def get_session_index():
    conn = _get_conn()
    
    # 1. Log Files (No filter - we want to see all logs)
    files = conn.execute('''
        SELECT session_id, MIN(timestamp), MAX(timestamp), COUNT(*), SUM(is_success)
        FROM attempts 
        WHERE session_id IS NOT NULL 
        GROUP BY session_id
    ''').fetchall()
    
    # 2. Splits (Must have at least 1 success to be valid)
    splits = conn.execute('''
        SELECT split_tag, MIN(timestamp), MAX(timestamp), COUNT(*), SUM(is_success)
        FROM attempts 
        WHERE split_tag IS NOT NULL 
        GROUP BY split_tag
        HAVING SUM(is_success) > 0
    ''').fetchall()
    
    results = []
    for row in files:
        results.append({
            'id': row[0], 'type': 'file', 'start_time': row[1], 
            'end_time': row[2], 'count': row[3], 'success_count': row[4] or 0
        })
    for row in splits:
        results.append({
            'id': row[0], 'type': 'split', 'start_time': row[1], 
            'end_time': row[2], 'count': row[3], 'success_count': row[4] or 0
        })
        
    results.sort(key=lambda x: x['start_time'], reverse=True)
    return results

def get_runs_by_session(session_id, session_type):
    """
    Fetches all runs for a specific session ID or Split Tag.
    """
    conn = _get_conn()
    
    if session_type == 'file':
        runs = conn.execute("SELECT * FROM attempts WHERE session_id = ? ORDER BY timestamp DESC", (session_id,)).fetchall()
    else:
        runs = conn.execute("SELECT * FROM attempts WHERE split_tag = ? ORDER BY timestamp DESC", (session_id,)).fetchall()
        
    return runs

def get_height_stats():
    conn = _get_conn()
    # Only consider positive heights and successful runs for stats
    rows = conn.execute('''
        SELECT height, COUNT(*), MIN(time_sec), MIN(total_explosives)
        FROM attempts 
        WHERE is_success = 1 AND height > 0
        GROUP BY height 
        ORDER BY height ASC
    ''').fetchall()
    return rows

def get_runs_by_height(height):
    conn = _get_conn()
    rows = conn.execute("SELECT * FROM attempts WHERE height = ? AND is_success = 1 ORDER BY timestamp ASC", (height,)).fetchall()
    return rows

def clear_db():
    conn = _get_conn()
    with conn:
        conn.execute("DELETE FROM attempts")
--- END OF FILE: database.py ---

--- START OF FILE: DATABASE_HISTORY.md ---
# MCSR Tracker — Database & Storage History

This file documents all database/storage decisions and changes throughout the project's lifecycle.
Use this as a reference when transitioning between frameworks (Flet → HTML/JS/CSS or other).

---

## v1.0 – Desktop App (Original)

- **Storage:** SQLite file on disk (`practice_stats.db`) in `%APPDATA%/MCSR_Tracker/`
- **Access:** Python `sqlite3` module with `threading.Lock()` for thread safety
- **Config:** JSON file (`config.json`) on disk in same directory
- **Connection pattern:** Open → query → close per operation (thread-safe via lock)

### Schema
```sql
CREATE TABLE IF NOT EXISTS attempts (
    id INTEGER PRIMARY KEY,
    timestamp TEXT,
    time_sec REAL,
    explosives TEXT,
    total_explosives INTEGER,
    tower TEXT,
    type TEXT,
    height INTEGER,
    bed_time REAL,
    is_success INTEGER,
    fail_reason TEXT,
    session_id TEXT,
    split_tag TEXT,
    fingerprint TEXT UNIQUE
)
```

### Column Index Map (for tuple access in components)
| Index | Column            | Type    | Notes |
|-------|-------------------|---------|-------|
| 0     | id                | INTEGER | Auto-increment PK |
| 1     | timestamp         | TEXT    | "YYYY-MM-DD HH:MM:SS" |
| 2     | time_sec          | REAL    | Run duration in seconds |
| 3     | explosives        | TEXT    | Raw string like "5+1", "4+2", "6" |
| 4     | total_explosives  | INTEGER | Computed: sum of parts (e.g., 5+1=6) |
| 5     | tower             | TEXT    | Tower name, "Unknown" for failures |
| 6     | type              | TEXT    | Run type, "Unknown" for failures |
| 7     | height            | INTEGER | Standing height, 0 for failures |
| 8     | bed_time          | REAL    | Time to first bed placement (nullable) |
| 9     | is_success        | INTEGER | 1=success, 0=fail |
| 10    | fail_reason       | TEXT    | "Death", "Reset", "World Load" (nullable) |
| 11    | session_id        | TEXT    | Log filename or "Live-YYYY-MM-DD" |
| 12    | split_tag         | TEXT    | User-defined practice split name (nullable) |
| 13    | fingerprint       | TEXT    | Dedup key: "{session_id}_{timestamp}_{time}" |

### Query Functions (database.py)
| Function                | Used By               | Returns      |
|-------------------------|-----------------------|--------------|
| `init_db()`             | main.py               | None         |
| `save_run(data)`        | engine.py             | bool         |
| `get_recent_runs(limit)`| recent_runs.py        | list[tuple]  |
| `get_tower_stats()`     | tower_analytics.py    | list[tuple]  |
| `get_runs_by_tower(name)`| tower_analytics.py   | list[tuple]  |
| `get_pbs_map()`         | recent_runs.py        | dict         |
| `get_session_index()`   | session_analytics.py  | list[dict]   |
| `get_runs_by_session()` | session_analytics.py  | list[tuple]  |
| `get_height_stats()`    | height_analytics.py   | list[tuple]  |
| `get_runs_by_height(h)` | height_analytics.py   | list[tuple]  |
| `clear_db()`            | settings dialog       | None         |

### Dedup Strategy
- `fingerprint = f"{session_id}_{timestamp}_{time}"`
- Column has `UNIQUE` constraint → `INSERT OR IGNORE` skips duplicates
- This means re-importing the same log files is safe

---

## v1.13 – Flet Web Transition (Current)

- **Date:** 2026-02-13
- **Motivation:** Users requested a webapp (hosted on GitHub Pages) so they don't need to install Python
- **Framework:** Still Python + Flet, but using `flet build web` (Pyodide/WebAssembly)

### What Changed
- **Storage:** SQLite in-memory (`:memory:`) — no file system in browser
- **Persistence:** Serialize all rows as JSON → store in browser storage (IndexedDB preferred, localStorage fallback)
- **Threading:** Removed entirely (not supported in Pyodide/browser)
- **Connection pattern:** Single global `_conn` object, no open/close per query
- **Config:** `page.client_storage` (Flet's localStorage wrapper) instead of file
- **Log import:** `ft.FilePicker` with multi-select instead of filesystem glob
- **Live watching:** Removed (impossible in browser)

### Schema: UNCHANGED
The SQL table schema is identical to v1.0. No columns added or removed.

### Query Functions: UNCHANGED
All function signatures and return types are identical. Components don't need changes.

### Key Decision: Why In-Memory SQLite + Serialization?
**Options considered:**
1. ~~File-based SQLite on Pyodide's MEMFS~~ — loses data on page reload
2. ~~`page.client_storage` key-value for everything~~ — no SQL queries, would require rewriting all components
3. **In-memory SQLite + JSON serialization to IndexedDB** ← CHOSEN
   - Keeps all SQL logic working unchanged
   - IndexedDB has hundreds of MB capacity (enough for tens of thousands of runs)
   - JSON serialization of rows is simple and debuggable
4. ~~Direct IndexedDB via JavaScript~~ — unnecessary complexity when option 3 works

### Persistence API
```python
save_to_storage(page)      # After import: serialize all rows → browser storage
load_from_storage(page)    # On startup: browser storage → in-memory SQLite
export_json()              # User-facing: download all data as .json file
import_json(data_str)      # User-facing: upload .json to restore data
```

---

## Future: HTML/JS/CSS Transition (Planned)

When transitioning away from Python/Flet to a pure frontend framework:

### What to Keep in Mind
- The **schema** is well-defined (see table above) — replicate it
- The **fingerprint dedup** system must be preserved
- Components access data via **tuple index** (e.g., `run[4]` = total_explosives)
  - In JS, consider using objects/dicts instead for clarity
- The **query functions** define the exact data contracts between DB and UI
  - Replicate these as JS functions returning the same shapes
- **IndexedDB** is already the persistence layer — transition should be smoother
- The **JSON export format** should remain backward-compatible so users don't lose data

### Recommended JS Stack for DB
- **sql.js** (SQLite compiled to WebAssembly) — drop-in replacement, same SQL
- Or **Dexie.js** (IndexedDB wrapper) — more browser-native but requires query rewrites
- Or **plain IndexedDB** — lowest level, most control

--- END OF FILE: DATABASE_HISTORY.md ---

--- START OF FILE: dist\assets\AssetManifest.bin.json ---
"DQoHMnBhY2thZ2VzL2N1cGVydGlub19pY29ucy9hc3NldHMvQ3VwZXJ0aW5vSWNvbnMudHRmDAENAQcFYXNzZXQHMnBhY2thZ2VzL2N1cGVydGlub19pY29ucy9hc3NldHMvQ3VwZXJ0aW5vSWNvbnMudHRmBzRwYWNrYWdlcy9mbHV0dGVyX21hcC9saWIvYXNzZXRzL2ZsdXR0ZXJfbWFwX2xvZ28ucG5nDAENAQcFYXNzZXQHNHBhY2thZ2VzL2ZsdXR0ZXJfbWFwL2xpYi9hc3NldHMvZmx1dHRlcl9tYXBfbG9nby5wbmcHKnBhY2thZ2VzL21lZGlhX2tpdC9hc3NldHMvd2ViL2hsczEuNC4xMC5qcwwBDQEHBWFzc2V0BypwYWNrYWdlcy9tZWRpYV9raXQvYXNzZXRzL3dlYi9obHMxLjQuMTAuanMHN3BhY2thZ2VzL3JlY29yZF93ZWIvYXNzZXRzL2pzL3JlY29yZC5maXh3ZWJtZHVyYXRpb24uanMMAQ0BBwVhc3NldAc3cGFja2FnZXMvcmVjb3JkX3dlYi9hc3NldHMvanMvcmVjb3JkLmZpeHdlYm1kdXJhdGlvbi5qcwcvcGFja2FnZXMvcmVjb3JkX3dlYi9hc3NldHMvanMvcmVjb3JkLndvcmtsZXQuanMMAQ0BBwVhc3NldAcvcGFja2FnZXMvcmVjb3JkX3dlYi9hc3NldHMvanMvcmVjb3JkLndvcmtsZXQuanMHKXBhY2thZ2VzL3dha2Vsb2NrX3BsdXMvYXNzZXRzL25vX3NsZWVwLmpzDAENAQcFYXNzZXQHKXBhY2thZ2VzL3dha2Vsb2NrX3BsdXMvYXNzZXRzL25vX3NsZWVwLmpzBzJwYWNrYWdlcy93aW5kb3dfbWFuYWdlci9pbWFnZXMvaWNfY2hyb21lX2Nsb3NlLnBuZwwBDQEHBWFzc2V0BzJwYWNrYWdlcy93aW5kb3dfbWFuYWdlci9pbWFnZXMvaWNfY2hyb21lX2Nsb3NlLnBuZwc1cGFja2FnZXMvd2luZG93X21hbmFnZXIvaW1hZ2VzL2ljX2Nocm9tZV9tYXhpbWl6ZS5wbmcMAQ0BBwVhc3NldAc1cGFja2FnZXMvd2luZG93X21hbmFnZXIvaW1hZ2VzL2ljX2Nocm9tZV9tYXhpbWl6ZS5wbmcHNXBhY2thZ2VzL3dpbmRvd19tYW5hZ2VyL2ltYWdlcy9pY19jaHJvbWVfbWluaW1pemUucG5nDAENAQcFYXNzZXQHNXBhY2thZ2VzL3dpbmRvd19tYW5hZ2VyL2ltYWdlcy9pY19jaHJvbWVfbWluaW1pemUucG5nBzdwYWNrYWdlcy93aW5kb3dfbWFuYWdlci9pbWFnZXMvaWNfY2hyb21lX3VubWF4aW1pemUucG5nDAENAQcFYXNzZXQHN3BhY2thZ2VzL3dpbmRvd19tYW5hZ2VyL2ltYWdlcy9pY19jaHJvbWVfdW5tYXhpbWl6ZS5wbmc="
--- END OF FILE: dist\assets\AssetManifest.bin.json ---

--- START OF FILE: dist\assets\AssetManifest.json ---
{"packages/cupertino_icons/assets/CupertinoIcons.ttf":["packages/cupertino_icons/assets/CupertinoIcons.ttf"],"packages/flutter_map/lib/assets/flutter_map_logo.png":["packages/flutter_map/lib/assets/flutter_map_logo.png"],"packages/media_kit/assets/web/hls1.4.10.js":["packages/media_kit/assets/web/hls1.4.10.js"],"packages/record_web/assets/js/record.fixwebmduration.js":["packages/record_web/assets/js/record.fixwebmduration.js"],"packages/record_web/assets/js/record.worklet.js":["packages/record_web/assets/js/record.worklet.js"],"packages/wakelock_plus/assets/no_sleep.js":["packages/wakelock_plus/assets/no_sleep.js"],"packages/window_manager/images/ic_chrome_close.png":["packages/window_manager/images/ic_chrome_close.png"],"packages/window_manager/images/ic_chrome_maximize.png":["packages/window_manager/images/ic_chrome_maximize.png"],"packages/window_manager/images/ic_chrome_minimize.png":["packages/window_manager/images/ic_chrome_minimize.png"],"packages/window_manager/images/ic_chrome_unmaximize.png":["packages/window_manager/images/ic_chrome_unmaximize.png"]}
--- END OF FILE: dist\assets\AssetManifest.json ---

--- START OF FILE: dist\assets\FontManifest.json ---
[{"family":"MaterialIcons","fonts":[{"asset":"fonts/MaterialIcons-Regular.otf"}]},{"family":"packages/cupertino_icons/CupertinoIcons","fonts":[{"asset":"packages/cupertino_icons/assets/CupertinoIcons.ttf"}]}]
--- END OF FILE: dist\assets\FontManifest.json ---

